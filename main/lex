void VOID_T	print IDENTIFIER	( LP	string STRING_T	str IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	H STRING	e STRING	l STRING	l STRING	o STRING	  STRING	w STRING	o STRING	r STRING	l STRING	d STRING	! STRING	\n STRING	"  END_LITERAL_STATE	) RP	; SEMICOLON	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	a STRING	\n STRING	"  END_LITERAL_STATE	) RP	; SEMICOLONvoid VOID_T	printInteger IDENTIFIER	( LP	integer INT_T	i IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	void VOID_T	print IDENTIFIER	( LP	string STRING_T	str IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	structure CLASS_T	M IDENTIFIER	\n NEW_LINE	{ LC	\n NEW_LINE	integer INT_T	a IDENTIFIER	; SEMICOLON	\n NEW_LINE	decimal DECIMAL_T	b IDENTIFIER	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	M IDENTIFIER	m IDENTIFIER	; SEMICOLON	\n NEW_LINE	m IDENTIFIER	. DOT	a IDENTIFIER	:= ASSIGN_T	0 INT LITERAL	; SEMICOLON	\n NEW_LINE	printInteger IDENTIFIER	( LP	m IDENTIFIER	. DOT	a IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	\n STRING	h STRING	a STRING	h STRING	a STRING	  STRING	i STRING	  STRING	a STRING	m STRING	  STRING	s STRING	u STRING	c STRING	c STRING	e STRING	s STRING	s STRING	f STRING	u STRING	l STRING	! STRING	! STRING	! STRING	\n STRING	"  END_LITERAL_STATE	) RP	; SEMICOLONvoid VOID_T	print IDENTIFIER	( LP	string STRING_T	str IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	void VOID_T	printInteger IDENTIFIER	( LP	integer INT_T	i IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	void VOID_T	printDecimal IDENTIFIER	( LP	decimal DECIMAL_T	i IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	structure CLASS_T	b IDENTIFIER	\n NEW_LINE	{ LC	\n NEW_LINE	integer INT_T	b IDENTIFIER	; SEMICOLON	\n NEW_LINE	decimal DECIMAL_T	a IDENTIFIER	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	b IDENTIFIER	c IDENTIFIER	; SEMICOLON	\n NEW_LINE	c IDENTIFIER	. DOT	a IDENTIFIER	:= ASSIGN_T	0.0 DECIMAL_LITERAL	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	integer INT_T	quickSort IDENTIFIER	( LP	integer INT_T	[ LB	] RB	a IDENTIFIER	, COMMA	integer INT_T	low IDENTIFIER	, COMMA	integer INT_T	high IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	if IF	( LP	low IDENTIFIER	>= GE	high IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	return RETURN_T	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	integer INT_T	first IDENTIFIER	:= ASSIGN_T	low IDENTIFIER	; SEMICOLON	\n NEW_LINE	integer INT_T	last IDENTIFIER	:= ASSIGN_T	high IDENTIFIER	; SEMICOLON	\n NEW_LINE	integer INT_T	key IDENTIFIER	:= ASSIGN_T	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	while WHILE	( LP	first IDENTIFIER	< LT	last IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	while WHILE	( LP	first IDENTIFIER	< LT	last IDENTIFIER	&& LOGICAL_AND	a IDENTIFIER	[ LB	last IDENTIFIER	] RB	>= GE	key IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	last IDENTIFIER	-- DECREMENT	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	:= ASSIGN_T	a IDENTIFIER	[ LB	last IDENTIFIER	] RB	; SEMICOLON	\n NEW_LINE	while WHILE	( LP	first IDENTIFIER	< LT	last IDENTIFIER	&& LOGICAL_AND	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	<= LE	key IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	first IDENTIFIER	++ INCREMENT	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	a IDENTIFIER	[ LB	last IDENTIFIER	] RB	:= ASSIGN_T	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	:= ASSIGN_T	key IDENTIFIER	; SEMICOLON	\n NEW_LINE	quickSort IDENTIFIER	( LP	a IDENTIFIER	, COMMA	low IDENTIFIER	, COMMA	first IDENTIFIER	- SUB	1 INT_LITERAL	) RP	; SEMICOLON	\n NEW_LINE	quickSort IDENTIFIER	( LP	a IDENTIFIER	, COMMA	first IDENTIFIER	+ ADD	1 INT_LITERAL	, COMMA	high IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	return RETURN_T	0 INT LITERAL	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	integer INT_T	[ LB	] RB	array IDENTIFIER	:= ASSIGN_T	{ LC	- SUB	1 INT_LITERAL	, COMMA	2 INT_LITERAL	, COMMA	32 INT_LITERAL	, COMMA	23 INT_LITERAL	, COMMA	5 INT_LITERAL	, COMMA	2490 INT_LITERAL	, COMMA	4859 INT_LITERAL	, COMMA	24 INT_LITERAL	, COMMA	545 INT_LITERAL	, COMMA	3 INT_LITERAL	, COMMA	4 INT_LITERAL	, COMMA	6 INT_LITERAL	, COMMA	8 INT_LITERAL	, COMMA	423 INT_LITERAL	, COMMA	67 INT_LITERAL	, COMMA	345 INT_LITERAL	, COMMA	543 INT_LITERAL	, COMMA	233 INT_LITERAL	, COMMA	17 INT_LITERAL	, COMMA	18 INT_LITERAL	, COMMA	39 INT_LITERAL	, COMMA	21 INT_LITERAL	, COMMA	66 INT_LITERAL	, COMMA	9 INT_LITERAL	, COMMA	0 INT LITERAL	, COMMA	49 INT_LITERAL	, COMMA	53 INT_LITERAL	, COMMA	77 INT_LITERAL	, COMMA	14 INT_LITERAL	, COMMA	20 INT_LITERAL	} RC	; SEMICOLON	\n NEW_LINE	quickSort IDENTIFIER	( LP	array IDENTIFIER	, COMMA	0 INT LITERAL	, COMMA	29 INT_LITERAL	) RP	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	integer INT_T	i IDENTIFIER	:= ASSIGN_T	0 INT LITERAL	; SEMICOLON	\n NEW_LINE	for FOR	( LP	; SEMICOLON	i IDENTIFIER	< LT	30 INT_LITERAL	; SEMICOLON	i IDENTIFIER	++ INCREMENT	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	  STRING	"  END_LITERAL_STATE	) RP	; SEMICOLON	\n NEW_LINE	// CC_COMMENT	print("a");\n NEW_LINE	printInteger IDENTIFIER	( LP	array IDENTIFIER	[ LB	i IDENTIFIER	] RB	) RP	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	\n STRING	"  END_LITERAL_STATE	) RP	; SEMICOLONvoid VOID_T	print IDENTIFIER	( LP	string STRING_T	str IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	void VOID_T	printInteger IDENTIFIER	( LP	integer INT_T	i IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	void VOID_T	printDecimal IDENTIFIER	( LP	decimal DECIMAL_T	i IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	structure CLASS_T	b IDENTIFIER	\n NEW_LINE	{ LC	\n NEW_LINE	integer INT_T	b IDENTIFIER	; SEMICOLON	\n NEW_LINE	decimal DECIMAL_T	a IDENTIFIER	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	b IDENTIFIER	c IDENTIFIER	; SEMICOLON	\n NEW_LINE	c IDENTIFIER	. DOT	a IDENTIFIER	:= ASSIGN_T	0.0 DECIMAL_LITERAL	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	integer INT_T	quickSort IDENTIFIER	( LP	integer INT_T	[ LB	] RB	a IDENTIFIER	, COMMA	integer INT_T	low IDENTIFIER	, COMMA	integer INT_T	high IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	if IF	( LP	low IDENTIFIER	>= GE	high IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	return RETURN_T	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	integer INT_T	first IDENTIFIER	:= ASSIGN_T	low IDENTIFIER	; SEMICOLON	\n NEW_LINE	integer INT_T	last IDENTIFIER	:= ASSIGN_T	high IDENTIFIER	; SEMICOLON	\n NEW_LINE	integer INT_T	key IDENTIFIER	:= ASSIGN_T	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	while WHILE	( LP	first IDENTIFIER	< LT	last IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	while WHILE	( LP	first IDENTIFIER	< LT	last IDENTIFIER	&& LOGICAL_AND	a IDENTIFIER	[ LB	last IDENTIFIER	] RB	>= GE	key IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	last IDENTIFIER	-- DECREMENT	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	:= ASSIGN_T	a IDENTIFIER	[ LB	last IDENTIFIER	] RB	; SEMICOLON	\n NEW_LINE	while WHILE	( LP	first IDENTIFIER	< LT	last IDENTIFIER	&& LOGICAL_AND	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	<= LE	key IDENTIFIER	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	first IDENTIFIER	++ INCREMENT	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	a IDENTIFIER	[ LB	last IDENTIFIER	] RB	:= ASSIGN_T	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	a IDENTIFIER	[ LB	first IDENTIFIER	] RB	:= ASSIGN_T	key IDENTIFIER	; SEMICOLON	\n NEW_LINE	quickSort IDENTIFIER	( LP	a IDENTIFIER	, COMMA	low IDENTIFIER	, COMMA	first IDENTIFIER	- SUB	1 INT_LITERAL	) RP	; SEMICOLON	\n NEW_LINE	quickSort IDENTIFIER	( LP	a IDENTIFIER	, COMMA	first IDENTIFIER	+ ADD	1 INT_LITERAL	, COMMA	high IDENTIFIER	) RP	; SEMICOLON	\n NEW_LINE	return RETURN_T	0 INT LITERAL	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	\n NEW_LINE	integer INT_T	[ LB	] RB	array IDENTIFIER	:= ASSIGN_T	{ LC	- SUB	1 INT_LITERAL	, COMMA	2 INT_LITERAL	, COMMA	32 INT_LITERAL	, COMMA	23 INT_LITERAL	, COMMA	5 INT_LITERAL	, COMMA	2490 INT_LITERAL	, COMMA	4859 INT_LITERAL	, COMMA	24 INT_LITERAL	, COMMA	545 INT_LITERAL	, COMMA	3 INT_LITERAL	, COMMA	4 INT_LITERAL	, COMMA	6 INT_LITERAL	, COMMA	8 INT_LITERAL	, COMMA	423 INT_LITERAL	, COMMA	67 INT_LITERAL	, COMMA	345 INT_LITERAL	, COMMA	543 INT_LITERAL	, COMMA	233 INT_LITERAL	, COMMA	17 INT_LITERAL	, COMMA	18 INT_LITERAL	, COMMA	39 INT_LITERAL	, COMMA	21 INT_LITERAL	, COMMA	66 INT_LITERAL	, COMMA	9 INT_LITERAL	, COMMA	0 INT LITERAL	, COMMA	49 INT_LITERAL	, COMMA	53 INT_LITERAL	, COMMA	77 INT_LITERAL	, COMMA	14 INT_LITERAL	, COMMA	20 INT_LITERAL	} RC	; SEMICOLON	\n NEW_LINE	quickSort IDENTIFIER	( LP	array IDENTIFIER	, COMMA	0 INT LITERAL	, COMMA	29 INT_LITERAL	) RP	; SEMICOLON	\n NEW_LINE	\n NEW_LINE	integer INT_T	i IDENTIFIER	:= ASSIGN_T	0 INT LITERAL	; SEMICOLON	\n NEW_LINE	for FOR	( LP	; SEMICOLON	i IDENTIFIER	< LT	30 INT_LITERAL	; SEMICOLON	i IDENTIFIER	++ INCREMENT	) RP	\n NEW_LINE	{ LC	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	  STRING	"  END_LITERAL_STATE	) RP	; SEMICOLON	\n NEW_LINE	// CC_COMMENT	print("a");\n NEW_LINE	printInteger IDENTIFIER	( LP	array IDENTIFIER	[ LB	i IDENTIFIER	] RB	) RP	; SEMICOLON	\n NEW_LINE	} RC	\n NEW_LINE	print IDENTIFIER	( LP	"  STRING_LITERAL_STATE	\n STRING	"  END_LITERAL_STATE	) RP	; SEMICOLON