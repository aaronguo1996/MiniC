\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
= EQ
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
; SEMICOLON
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n 
; SEMICOLON
i IDENTIFIER
\n NEW_LINE
;)i(f// CC_COMMENT
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
a IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
*/ END_COMMENT
}\n END_COMMENT
;n/k nruter   \n END_COMMENT
;4.3 =: n lamiced   \n END_COMMENT
;2.1 =: k lamiced   \n END_COMMENT
{\n END_COMMENT
)i regetni(f lamiced/* C_COMMENT
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
\n 
} RC
\n 
; SEMICOLON
b IDENTIFIER
  EMPTY
return RETURN_T
\n 
} RC
\n NEW_LINE
;i// CC_COMMENT
\n 
; SEMICOLON
) RP
i IDENTIFIER
( LP
f IDENTIFIER
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
: COLON
  EMPTY
a IDENTIFIER
  EMPTY
( LP
foreach FOREACH
\n 
} RC
\n 
; SEMICOLON
++ INCREMENT
b IDENTIFIER
\n 
{ LC
) RP
0 INT LITERAL
< LT
b IDENTIFIER
( LP
while WHILE
\n 
} RC
\n 
; SEMICOLON
-- DECREMENT
b IDENTIFIER
  EMPTY
\n 
{ LC
\n 
) RP
++ INCREMENT
i IDENTIFIER
; SEMICOLON
9 INT_LITERAL
< LT
i IDENTIFIER
; SEMICOLON
0 INT LITERAL
= EQ
i IDENTIFIER
( LP
for FOR
\n 
; SEMICOLON
i IDENTIFIER
  EMPTY
integer INT_T
\n 
} RC
\n 
; SEMICOLON
12 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
d IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
else ELSE
} RC
\n 
; SEMICOLON
9 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
  EMPTY
< LT
  EMPTY
b IDENTIFIER
  EMPTY
&& LOGICAL_AND
  EMPTY
0 INT LITERAL
  EMPTY
> GT
  EMPTY
b IDENTIFIER
( LP
elseif ELSEIF
} RC
\n 
; SEMICOLON
0 INT LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
c IDENTIFIER
  EMPTY
integer INT_T
  EMPTY
  EMPTY
\n 
{ LC
) RP
10 INT_LITERAL
>= GE
b IDENTIFIER
( LP
if IF
\n 
; SEMICOLON
3 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
b IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
} RC
4 INT_LITERAL
, COMMA
3 INT_LITERAL
, COMMA
2 INT_LITERAL
, COMMA
1 INT_LITERAL
{ LC
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
] RB
4 INT_LITERAL
[ LB
integer INT_T
  EMPTY
new NEW
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
] RB
[ LB
integer INT_T
\n 
; SEMICOLON
5 INT_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
a IDENTIFIER
. DOT
rr IDENTIFIER
\n 
; SEMICOLON
rr IDENTIFIER
  EMPTY
m IDENTIFIER
\n 
{ LC
\n 
) RP
( LP
test IDENTIFIER
  EMPTY
integer INT_T
\n 
\n 
} RC
\n 
; SEMICOLON
n IDENTIFIER
/ DIV
k IDENTIFIER
  EMPTY
return RETURN_T
  EMPTY
  EMPTY
  EMPTY
\n 
; SEMICOLON
3.4 DECIMAL_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
n IDENTIFIER
  EMPTY
decimal DECIMAL_T
  EMPTY
  EMPTY
  EMPTY
\n 
; SEMICOLON
1.2 DECIMAL_LITERAL
  EMPTY
:= ASSIGN_T
  EMPTY
k IDENTIFIER
  EMPTY
decimal DECIMAL_T
  EMPTY
  EMPTY
  EMPTY
\n 
{ LC
\n 
) RP
i IDENTIFIER
  EMPTY
integer INT_T
( LP
f IDENTIFIER
  EMPTY
decimal DECIMAL_T
\n 
\n 
} RC
\n 
; SEMICOLON
a IDENTIFIER
  EMPTY
integer INT_T
\n 
; SEMICOLON
c IDENTIFIER
  EMPTY
integer INT_T
\n 
{ LC
\n 
m IDENTIFIER
  EMPTY
struct CLASS_T
